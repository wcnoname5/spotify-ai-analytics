import pydantic
from typing import List, Optional, Any, Dict, Literal
from pydantic import Field

class ToolPlan(pydantic.BaseModel):
    """Plan for a single tool execution."""
    tool_name: Literal[
        "get_summary_stats", 
        "get_top_artists",
        "get_top_tracks",
        "free_query",
        "free_aggregate"
    ] = Field(
        ..., 
        description="Name of the tool to be executed"
    )
    reasoning: str = Field(
        default="",
        description="Reasoning for why this tool is selected"
    )
    args: Optional[Dict[str, Any]] = Field(
        default_factory=dict,
        description="Arguments for the tool (Optional, will be refined by downstream node)"
    )

class IntentPlan(pydantic.BaseModel):
    """Execution plan generated by the Planner node."""
    intent_type: Literal["factual_query", "insight_analysis", "recommendation", "other"] = Field(
        ..., 
        description="The category of the user's request."
    )
    reasoning: str = Field(..., description="Brief reason why this intent was chosen.")
    analysis_focus: str = Field(
        default="", 
        description="If intent is analysis, what specific patterns should be looked at?"
    )
    tool_plan: List[ToolPlan] = Field(
        default_factory=list, 
        description="Planned tools to execute in order"
    )

class ToolFreeQueryArgs(pydantic.BaseModel):
    """Arguments for the free_query tool."""
    where: Optional[str] = pydantic.Field(None, description="Polars filter expression as a string, e.g., \"pl.col('artist') == 'Taylor Swift'\"")
    select: Optional[List[str]] = pydantic.Field(None, description="List of column names to include")
    limit: Optional[int] = pydantic.Field(None, description="Maximum number of rows to return")
    sort_by: Optional[str] = pydantic.Field(None, description="Column name to sort by")
    descending: bool = pydantic.Field(True, description="Whether to sort in descending order")

class ToolFreeAggrgateArgs(pydantic.BaseModel):
    """Arguments for the free_aggregate tool."""
    group_by: List[str] = pydantic.Field(..., description="List of column names to group by")
    metrics: Dict[str, Any] = pydantic.Field(..., description="Dictionary mapping columns to aggregation functions (sum, mean, count, n_unique). Value can be a string or a (function, alias) tuple.")
    where: Optional[str] = pydantic.Field(None, description="Polars filter expression as a string")
    sort_by: Optional[str] = pydantic.Field(None, description="Column name to sort by")
    descending: bool = pydantic.Field(True, description="Whether to sort in descending order")
    limit: Optional[int] = pydantic.Field(None, description="Maximum number of rows to return")